<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xbadc0de</title>
  
  <subtitle>日拱一卒,功不唐捐</subtitle>
  <link href="https://ryany1.github.io/atom.xml" rel="self"/>
  
  <link href="https://ryany1.github.io/"/>
  <updated>2024-10-19T16:44:02.751Z</updated>
  <id>https://ryany1.github.io/</id>
  
  <author>
    <name>ryany</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>劝学</title>
    <link href="https://ryany1.github.io/2024/5b4d/"/>
    <id>https://ryany1.github.io/2024/5b4d/</id>
    <published>2024-10-19T16:42:22.000Z</published>
    <updated>2024-10-19T16:44:02.751Z</updated>
    
    <content type="html"><![CDATA[<p>　　君子曰：学不可以已。</p><p>　　青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。</p><span id="more"></span><p>　　故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。</p><p>　　吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。(君子生 通：性)</p><p>　　南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。</p><p>　　物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蜹聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！</p><p>　　积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。(江海 一作：江河)</p><p>　　是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，鼫鼠五技而穷。《诗》曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮！”故君子结于一也。</p><p>　　昔者瓠巴鼓瑟，而流鱼出听；伯牙鼓琴，而六马仰秣。故声无小而不闻，行无隐而不形。玉在山而草木润，渊生珠而崖不枯。为善不积邪？安有不闻者乎？</p><p>　　学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人，真积力久则入，学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之，人也；舍之，禽兽也。故书者，政事之纪也；诗者，中声之所止也；礼者，法之大分，类之纲纪也 故学至乎礼而止矣。夫是之谓道德之极。礼之敬文也，乐之中和也，诗书之博也，春秋之微也，在天地之间者毕矣。</p><p>　　君子之学也，入乎耳，箸乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口；口耳之间，则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲非也，囋非也；君子如向矣。</p><p>　　学莫便乎近其人。礼乐法而不说，诗书故而不切，春秋约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。</p><p>　　学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺诗书而已耳。则末世穷年，不免为陋儒而已。将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以诗书为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。</p><p>　　问楛者，勿告也；告楛者，勿问也；说楛者，勿听也。有争气者，勿与辩也。故必由其道至，然后接之；非其道则避之。故礼恭，而后可与言道之方；辞顺，而后可与言道之理；色从而后可与言道之致。故未可与言而言，谓之傲；可与言而不言，谓之隐；不观气色而言，谓瞽。故君子不傲、不隐、不瞽，谨顺其身。诗曰：“匪交匪舒，天子所予。”此之谓也。</p><p>　　百发失一，不足谓善射；千里蹞步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀纣盗跖也；全之尽之，然后学者也。</p><p>　　君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使耳非是无欲闻也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　君子曰：学不可以已。&lt;/p&gt;
&lt;p&gt;　　青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木直中绳，輮以为轮，其曲中规。虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Others" scheme="https://ryany1.github.io/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Follow Certification</title>
    <link href="https://ryany1.github.io/2024/bff/"/>
    <id>https://ryany1.github.io/2024/bff/</id>
    <published>2024-10-08T02:00:15.000Z</published>
    <updated>2024-10-08T02:03:51.755Z</updated>
    
    <content type="html"><![CDATA[<p>This message is used to verify that this feed (feedId:66295217578569728) belongs to me (userId:59531562445839360). Join me in enjoying the next generation information browser <a href="https://follow.is/">https://follow.is</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;This message is used to verify that this feed (feedId:66295217578569728) belongs to me (userId:59531562445839360). Join me in enjoying th</summary>
      
    
    
    
    
    <category term="Others" scheme="https://ryany1.github.io/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Standard-IO</title>
    <link href="https://ryany1.github.io/2024/6c83/"/>
    <id>https://ryany1.github.io/2024/6c83/</id>
    <published>2024-09-21T03:53:11.586Z</published>
    <updated>2024-03-28T08:45:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UNIX系统文件IO"><a href="#UNIX系统文件IO" class="headerlink" title="UNIX系统文件IO"></a>UNIX系统文件IO</h2><blockquote><p>相关库: unistd.h</p><p>IO操作: 系统空间&lt;–数据–&gt;物理设备(终端,磁盘文件等)</p></blockquote><p>文件IO都是无缓冲IO(unbuffered IO)，<font color="blue">不在ISO C标准内</font>文件IO主要函数为<code>open,read,write,lseek,close</code>,因为每调用一个<code>read,write</code>都会执行一次内核中的一次系统调用(read,write),文件IO通过文件描述符(FD)引用文件。</p><span id="more"></span><ul><li>read函数读取文件内容过程，进程调用系统调用read将数据加载到内核页缓存（read ahead），随后进程从页缓存读取需要的数据到进程用户空间（read函数指定的buffer）下次read调用可能直接从页缓存请求数据了，不需要执行IO操作，（#ryany_question:这是不是都是内核态操作）</li><li>write函数写入文件，write使用<code>delayed write</code>机制写入数据到磁盘,见下文</li></ul><p>附:</p><ul><li>文件描述符,进程通过文件描述符引用文件(一个正整数)<ul><li>特殊系统描述符<ul><li><code>0</code>:程序标准输入,linux系统中可以等价于<code>/dev/stdin</code>使用</li><li><code>1</code>:程序标准输出</li><li><code>2</code>:程序标准错误输出</li></ul></li><li>linux系统下<code>/dev/fd/</code>下可以看到系统中现有的文件描述符<ul><li>系统中fd最大值可以使用<code>ulimit -n</code>查看,这说明系统进程最多支持使用这么多数的文件</li></ul></li></ul></li><li>文件IO读写缓冲(系统层级对减少IO操作的优化)<ul><li><code>read ahead</code><ul><li>这种机制是由文件系统支持的</li><li>系统调用read请求从磁盘顺序读取数据，系统会试图读取大于要求的数据，并假定进程会很快使用这些数据</li><li>文件系统将磁盘划分为块,这是用户存储数据的最小单位<code>dumpe2fs /dev/sdb | grep &quot;Block size&quot; --&gt; 4096</code>，对于大文件指定buffersize为这个blocksize的整数倍将效率最好，见epua手册图3-6</li></ul></li><li><code>delayed write</code><ul><li>系统调用write写入数据到磁盘，系统会将这些待写入的数据块暂存到内核页缓存，并将操作排入队列，待累积一定量之后写入磁盘</li><li>显性调用相关函数<code>fsync,fdatasync</code>将冲洗缓冲，将数据写入磁盘</li></ul></li></ul></li></ul><h2 id="ISO-C-Standard-IO"><a href="#ISO-C-Standard-IO" class="headerlink" title="ISO-C_Standard-IO"></a>ISO-C_Standard-IO</h2><blockquote><p>类unix系统中，标准IO底层也是系统read，write调用</p><p>类unix系统中，标准IO感觉更像对文件IO的封装，流将文件IO封装起来，用户不需要关心底层文件IO的工作，大大降低了操作难度，尤其引入流缓冲区，大大提高了IO效率</p><p>文件IO很多操作被标准IO隐藏到了流缓冲&lt;–&gt;设备&#x2F;文件这个过程当中去了,而这个过程是自动的</p></blockquote><p>标准IO操作围绕流展开，程序员使用一个FILE指针在代码内操作流，这个指针指向一个结构体，结构体内有被引用文件文件描述符，流缓冲指针等信息。</p><h3 id="缓冲-buffering"><a href="#缓冲-buffering" class="headerlink" title="缓冲(buffering)"></a>缓冲(buffering)</h3><p>缓冲的引入,降低了系统<code>read,write</code>调用的次数,(这个缓冲位于内存用户空间)程序从流缓冲区读取数据或者写入数据,提高了IO效率,<font color="red">缓冲是流的属性</font>,标准IO提供以下几种缓冲</p><ul><li><p>buffered</p><ul><li><p>line buffering</p><ul><li><p>当流引用交互式设备,使用行缓冲,像关联到终端的stdin,stdout(当然我们可以让这些流重定向到文件)</p></li><li><p>写出:(程序终端标准输出)所有用户想要写出的内容都被写入流缓冲,行缓冲在当缓冲区满,或者缓冲区出现换行符,冲洗缓冲(fflush),流被关闭时才会将缓冲区内容写出(IO操作)</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> c;<br>    c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-built_in">putchar</span>(c);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<span class="hljs-comment">//printf(&quot;hello&quot;);</span><br>    sleep(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  以上代码运行可见全缓冲IO操作的时刻,printf不打印换行符时,将在延迟10s后,程序结束,流被关闭时,数据被写出到终端,当printf打印换行符时,在延迟10s前,数据就被写出到终端了</p></li><li><p>读入:(终端stdin)用户输入时数据读到缓冲区,当缓冲区中出现换行符时,程序从缓冲区读取数据</p></li></ul></li><li><p>full buffering</p><ul><li><p>流引用文件,默认使用全缓冲,系统默认流缓冲大小为8K,unix文件IO章节(epua手册)中测试了read缓冲区大小设置对IO执行效率的影响,因此流缓冲长度应该大于磁盘块长度,并且尽量是它的整数倍长度</p></li><li><p>读入:程序使用标准IO函数请求读入数据,流将调用read读取尽量多的数据(哪怕到EOF,读到EOF不够填充满也可以)区填充满流缓冲,随后程序从流缓冲读取需要的数据,下次fread读取直接从缓冲区读,fread等函数能够正确处理EOF</p></li><li><p>写出:程序写出到文件被写入流缓冲,只有当缓冲满,流关闭,冲洗缓冲时,缓冲区内容被写入文件</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    FILE *fp;<br>    <span class="hljs-type">char</span> *ch = <span class="hljs-string">&quot;hello, world!&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    fp = fopen(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    fwrite(ch, <span class="hljs-number">1</span>, <span class="hljs-number">13</span>, fp);<br>    <span class="hljs-comment">//fflush(fp);</span><br>    sleep(<span class="hljs-number">15</span>);<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  上述代码在linux中执行,我们使用两个终端,一个运行程序,一个观察文件内容,当fflush被注释时,我们只有当程序结束时,才能看到文件被写入的内容,当fflush被调用时,我们马上能看到被写入的内容(方法比较笨),</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    FILE *fp;<br>    <span class="hljs-type">char</span> *ch = <span class="hljs-string">&quot;hello, world!&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    fp = fopen(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    fwrite(ch, <span class="hljs-number">1</span>, <span class="hljs-number">13</span>, fp);<br>  <span class="hljs-comment">//  fflush(fp);</span><br>    fork();<span class="hljs-comment">//unistd.h</span><br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  改进代码,我们创建进程副本验证fwrite之后,内容有没有被写入文件,很显然,缓冲区内容被克隆到了子进程,最终,我们要写入的内容被重复写入了文件,在fork之前调用fflush之后,我们文件内只有一份内容了</p></li></ul></li></ul></li><li><p>non-buffering</p><ul><li>关联到终端的stderr使用无缓冲输出,用户能尽快的看到报错(重定向到文件的stderr使用全缓冲)</li></ul></li></ul><h3 id="标准IO操作"><a href="#标准IO操作" class="headerlink" title="标准IO操作"></a>标准IO操作</h3><blockquote><p>不带f的函数都是操作标准输出输入流的,我们使用带f的函数</p></blockquote><ul><li>每次一个IO,(希望)一个字符接一个字符的读入或者写出<ul><li>fgetc,getc,getchar,fputc,putc,putchar</li></ul></li><li>每次一行IO,(希望)一行接一行的读入或者写出<ul><li>fgets,gets(c11中被废弃,不能指定缓冲区,可能造成流缓冲溢出产生安全问题),fputs,puts</li></ul></li><li>每次一块IO(这是我的叫法,也叫直接IO等,见epua手册5.6章节)<ul><li>fread,fwrite,读取或者写入指定大小的块,书里说用来读取写入结构</li></ul></li></ul><p>以上都是非格式化IO函数,格式化IO函数有printf,scanf</p><p><font color="red">注意:</font>以上IO操作是和流的缓冲是配合工作的,或者说这些IO操作是被流给优化了的,比如,我(程序员)想一行一行的写入文件,但流说:”你这样多慢,我先给你把这些行存下来,使用全缓冲进行写入,这样多快”,这时我的预期和现实就割裂了,这时你如果意识不到这种割裂就容易出岔子.拿捏不准直接fflush</p><h3 id="标准IO提供的函数的一些注意事项-待补充"><a href="#标准IO提供的函数的一些注意事项-待补充" class="headerlink" title="标准IO提供的函数的一些注意事项(待补充)"></a>标准IO提供的函数的一些注意事项(待补充)</h3><ul><li>scanf<ul><li><p>scanf阻塞：若此时缓冲区为空（有回车符也行），你按回车会导致scanf阻塞，直到你输入一个有效值（非回车，不匹配scanf格式也可以），这些回车不会堆积在缓冲区</p></li><li><p>scanf缓冲区回车符残留问题，终端stdin为行缓冲，需要回车符执行IO操作，但scanf不会吸收这个回车，这个回车会残留在缓冲区中，下个scanf可能被这个回车符阻塞，也可能将这个回车符吸收<code>scanf(&quot;%c&quot;,xxx)</code></p></li><li><p>scanf如何处理不合法字符：scanf将跳过不合法（不符合scanf格式要求）的字符，这些字符将残留在缓冲区当中，下面代码如果你输入一个非数字字符，将进入死循环</p></li><li><p>如何处理scanf残留在缓冲区的回车符：<code>scanf(&quot;[space]%x&quot;,xxx) or getchar() before scanf</code>，[space]可以吸收回车等一些字符，若是没有回车残留则需要用户手动输入一个回车</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> c;<br>getchar();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c) == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is a infinate loop&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><p>参考内容</p><ul><li>UNIX环境高级编程书籍</li><li><a href="https://www.gnu.org/software/libc/manual/html_node/Stream-Buffering.html">Stream Buffering (The GNU C Library)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;UNIX系统文件IO&quot;&gt;&lt;a href=&quot;#UNIX系统文件IO&quot; class=&quot;headerlink&quot; title=&quot;UNIX系统文件IO&quot;&gt;&lt;/a&gt;UNIX系统文件IO&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;相关库: unistd.h&lt;/p&gt;
&lt;p&gt;IO操作: 系统空间&amp;lt;–数据–&amp;gt;物理设备(终端,磁盘文件等)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件IO都是无缓冲IO(unbuffered IO)，&lt;font color=&quot;blue&quot;&gt;不在ISO C标准内&lt;/font&gt;文件IO主要函数为&lt;code&gt;open,read,write,lseek,close&lt;/code&gt;,因为每调用一个&lt;code&gt;read,write&lt;/code&gt;都会执行一次内核中的一次系统调用(read,write),文件IO通过文件描述符(FD)引用文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C" scheme="https://ryany1.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C运算符优先级</title>
    <link href="https://ryany1.github.io/2024/2e96/"/>
    <id>https://ryany1.github.io/2024/2e96/</id>
    <published>2024-07-28T15:59:20.000Z</published>
    <updated>2024-07-28T16:03:35.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言运算符优先级-持续更新"><a href="#C语言运算符优先级-持续更新" class="headerlink" title="C语言运算符优先级(持续更新)"></a>C语言运算符优先级(持续更新)</h1><p>在C语言中，运算符的优先级决定了表达式中运算符的计算顺序。以下是C语言运算符优先级从高到低的列表：</p><ol><li><strong>后缀运算符</strong><ul><li><code>expr++</code>, <code>expr--</code> (后缀递增和递减)</li><li><code>()</code>, <code>[]</code>, <code>.</code> (函数调用，数组下标，成员访问)</li><li><code>-&gt;</code> (指针成员访问)</li></ul></li></ol><span id="more"></span><ol start="2"><li><p><strong>单目运算符</strong></p><ul><li><code>++expr</code>, <code>--expr</code> (前缀递增和递减)</li><li><code>+</code>, <code>-</code> (正负号)</li><li><code>!</code>, <code>~</code> (逻辑非和按位取反)</li><li><code>(type)</code> (类型转换)</li><li><code>*</code> (指针解引用)</li><li><code>&amp;</code> (取地址)</li><li><code>sizeof</code> (求大小)</li><li><code>_Alignof</code> (求对齐)</li></ul></li><li><p><strong>乘法与除法</strong></p><ul><li><code>*</code>, <code>/</code>, <code>%</code> (乘法，除法，取模)</li></ul></li><li><p><strong>加法与减法</strong></p><ul><li><code>+</code>, <code>-</code> (加法，减法)</li></ul></li><li><p><strong>移位运算</strong></p><ul><li><code>&lt;&lt;</code>, <code>&gt;&gt;</code> (左移，右移)</li></ul></li><li><p><strong>关系运算符</strong></p><ul><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> (小于，小于等于，大于，大于等于)</li></ul></li><li><p><strong>相等运算符</strong></p><ul><li><code>==</code>, <code>!=</code> (等于，不等于)</li></ul></li><li><p><strong>按位与</strong></p><ul><li><code>&amp;</code></li></ul></li><li><p><strong>按位异或</strong></p><ul><li><code>^</code></li></ul></li><li><p><strong>按位或</strong></p><ul><li><code>|</code></li></ul></li><li><p><strong>逻辑与</strong></p><ul><li><code>&amp;&amp;</code></li></ul></li><li><p><strong>逻辑或</strong></p><ul><li><code>||</code></li></ul></li><li><p><strong>条件运算符</strong></p><ul><li><code>?:</code></li></ul></li><li><p><strong>赋值运算符</strong></p><ul><li><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code></li></ul></li><li><p><strong>逗号运算符</strong></p><ul><li><code>,</code></li></ul></li></ol><p>运算符优先级决定了当多个运算符出现在一个表达式中时，先计算哪个运算符。如果优先级相同，则根据结合性规则决定计算顺序。结合性有两种：从左到右和从右到左。例如，大多数二元运算符（如加法和乘法）都是从左到右结合，而赋值运算符是从右到左结合。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>逗号表达式用于三目条件运算，特别注意给逗号表达式加括号</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p</span> = p &lt; <span class="hljs-number">0</span> ? negative = <span class="hljs-literal">true</span>, -p : negative = <span class="hljs-literal">false</span>, p<span class="hljs-comment">; </span><br><br></code></pre></td></tr></table></figure><p>此时这个表达式被解释为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">p</span> = (p &lt; <span class="hljs-number">0</span> ? (negative = <span class="hljs-literal">true</span>, -p) : negative = <span class="hljs-literal">false</span>), p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">*ptr++<br></code></pre></td></tr></table></figure><p>一元运算符<em>和++的优先级相同， 但结合律是从右往左， 所以start++先求值， 然后才是</em>start。 也就是说， 指针start先递增后指向。</p><hr><p>*与&amp;互为逆操作,&amp;*ptr &#x3D;&#x3D; ptr &#x3D;&#x3D; *&amp;ptr,当根据运算优先级* &gt; &amp;,<code>*&amp;ptr</code>无法解释,这种用法编译器报错,<code>&amp;*ptr</code>可行</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C语言运算符优先级-持续更新&quot;&gt;&lt;a href=&quot;#C语言运算符优先级-持续更新&quot; class=&quot;headerlink&quot; title=&quot;C语言运算符优先级(持续更新)&quot;&gt;&lt;/a&gt;C语言运算符优先级(持续更新)&lt;/h1&gt;&lt;p&gt;在C语言中，运算符的优先级决定了表达式中运算符的计算顺序。以下是C语言运算符优先级从高到低的列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;后缀运算符&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;expr++&lt;/code&gt;, &lt;code&gt;expr--&lt;/code&gt; (后缀递增和递减)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; (函数调用，数组下标，成员访问)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; (指针成员访问)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="C" scheme="https://ryany1.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>init</title>
    <link href="https://ryany1.github.io/2024/3652/"/>
    <id>https://ryany1.github.io/2024/3652/</id>
    <published>2024-03-22T14:00:23.000Z</published>
    <updated>2024-03-23T03:42:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>hello</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hello&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
